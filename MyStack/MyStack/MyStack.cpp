#include "MyStack.h"
#include <iostream>

using namespace std;

namespace MyContainers {// Определяем пространство имен MyContainers, чтобы избежать конфликтов имен

// Конструктор класса Stack
Stack::Stack(int capacity) : capacity(capacity), top(-1) {
    // capacity(capacity), top(-1) - это список инициализации, инициализирующий поля capacity и top

    // Проверяем, является ли переданная вместимость допустимой (больше нуля)
    if (capacity <= 0) {
        cerr << "Ошибка: Вместимость стека должна быть больше нуля. Установлена вместимость по умолчанию (10)." << endl;
        // Если вместимость недействительна, выводим сообщение об ошибке в cerr
        // и устанавливаем вместимость равной 10 по умолчанию
        this->capacity = 10;
    }
    arr = new char[this->capacity];  // Выделяем динамическую память для массива символов размером capacity
    // arr - это указатель на первый элемент массива (наш стек)
}

// Деструктор класса Stack: освобождает выделенную память, выделенную для стека
Stack::~Stack() {
    delete[] arr;  // Освобождаем память, чтобы избежать утечек памяти
}

// Оператор присваивания: позволяет присвоить один стек другому
Stack& Stack::operator=(const Stack& other) {
    // Проверяем, не пытаемся ли мы присвоить стек самому себе
    if (this != &other) {
        delete[] arr;  // Освобождаем память, занимаемую текущим стеком

        capacity = other.capacity;  // Копируем вместимость из другого стека
        top = other.top;            // Копируем индекс верхнего элемента из другого стека
        arr = new char[capacity];  // Выделяем память для нового массива
        for (int i = 0; i <= top; ++i) {
            arr[i] = other.arr[i];  // Копируем элементы из другого стека
        }
    }
    return *this;  // Возвращаем ссылку на текущий объект (для цепочки присваиваний)
}

// Проверяет, является ли стек пустым
bool Stack::isEmpty() const {
    return top == -1;  // Если top равен -1, значит, стек пуст
}

// Проверяет, является ли стек полным
bool Stack::isFull() const {
    return top == capacity - 1;  // Если top равен capacity - 1, значит, стек полон
}

// Добавляет элемент в стек
void Stack::push(char element) {
    // Сначала проверяем, не полон ли стек
    if (isFull()) {
        resize();  // Если полон, увеличиваем его размер
    }
    arr[++top] = element;  // Увеличиваем top (индекс верхнего элемента) и добавляем элемент в стек
}

// Удаляет элемент с вершины стека и возвращает его
char Stack::pop() {
    // Проверяем, не пуст ли стек
    if (isEmpty()) {
        cerr << "Ошибка: Попытка извлечения элемента из пустого стека." << endl;
        // Если стек пуст, выводим сообщение об ошибке и возвращаем символ null
        return '\0';  // Или можно бросить исключение для более надежной обработки ошибок
    }
    return arr[top--];  // Возвращаем элемент с вершины стека и уменьшаем top
}

// Возвращает элемент с вершины стека, не удаляя его
char Stack::peek() const {
    // Проверяем, не пуст ли стек
    if (isEmpty()) {
        cerr << "Ошибка: Попытка просмотра вершины пустого стека." << endl;
        // Если стек пуст, выводим сообщение об ошибке и возвращаем символ null
        return '\0';  // Или можно бросить исключение
    }
    return arr[top];  // Возвращаем элемент с вершины стека
}

// Возвращает текущий размер стека (количество элементов в стеке)
int Stack::getSize() const {
    return top + 1;  // Размер стека - это top + 1
}

// Увеличивает размер стека (динамически выделенного массива)
void Stack::resize() {
    int newCapacity = capacity * 2;  // Удваиваем вместимость
    char* newArr = new char[newCapacity];  // Выделяем новую память
    for (int i = 0; i <= top; ++i) {
        newArr[i] = arr[i];  // Копируем элементы из старого массива в новый
    }
    delete[] arr;  // Освобождаем старую память
    arr = newArr;  // Переназначаем указатель arr на новый массив
    capacity = newCapacity;  // Обновляем вместимость
    cout << "Стек расширен до вместимости: " << capacity << endl; // Выводим сообщение об увеличении размера (для отладки)
}
} // namespace MyContainers
